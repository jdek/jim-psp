diff -burN insight-6.1/bfd/archures.c insight-6.1-psp/bfd/archures.c
--- insight-6.1/bfd/archures.c	2003-12-03 17:38:48.000000000 +0000
+++ insight-6.1-psp/bfd/archures.c	2005-09-19 17:11:59.159476712 +0100
@@ -146,6 +146,7 @@
 .#define bfd_mach_mips16		16
 .#define bfd_mach_mips5                 5
 .#define bfd_mach_mips_sb1              12310201 {* octal 'SB', 01 *}
+.#define bfd_mach_mips_allegrex         10111431 {* octal 'AL', 31 *}
 .#define bfd_mach_mipsisa32             32
 .#define bfd_mach_mipsisa32r2           33
 .#define bfd_mach_mipsisa64             64
diff -burN insight-6.1/bfd/bfd-in2.h insight-6.1-psp/bfd/bfd-in2.h
--- insight-6.1/bfd/bfd-in2.h	2004-02-16 18:46:40.000000000 +0000
+++ insight-6.1-psp/bfd/bfd-in2.h	2005-09-19 17:11:59.169475192 +0100
@@ -1578,6 +1578,7 @@
 #define bfd_mach_mips16                16
 #define bfd_mach_mips5                 5
 #define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+#define bfd_mach_mips_allegrex         10111431 /* octal 'AL', 31 */
 #define bfd_mach_mipsisa32             32
 #define bfd_mach_mipsisa32r2           33
 #define bfd_mach_mipsisa64             64
diff -burN insight-6.1/bfd/cpu-mips.c insight-6.1-psp/bfd/cpu-mips.c
--- insight-6.1/bfd/cpu-mips.c	2003-12-08 20:04:34.000000000 +0000
+++ insight-6.1-psp/bfd/cpu-mips.c	2005-09-19 17:11:59.170475040 +0100
@@ -85,6 +85,7 @@
   I_mipsisa64,
   I_mipsisa64r2,
   I_sb1,
+  I_allegrex,
 };
 
 #define NN(index) (&arch_info_struct[(index) + 1])
@@ -116,7 +117,8 @@
   N (32, 32, bfd_mach_mipsisa32r2,"mips:isa32r2", FALSE, NN(I_mipsisa32r2)),
   N (64, 64, bfd_mach_mipsisa64,  "mips:isa64",   FALSE, NN(I_mipsisa64)),
   N (64, 64, bfd_mach_mipsisa64r2,"mips:isa64r2", FALSE, NN(I_mipsisa64r2)),
-  N (64, 64, bfd_mach_mips_sb1, "mips:sb1",       FALSE, 0),
+  N (64, 64, bfd_mach_mips_sb1, "mips:sb1",       FALSE, NN(I_sb1)),
+  N (32, 32, bfd_mach_mips_allegrex, "mips:allegrex", FALSE, 0),
 };
 
 /* The default architecture is mips:3000, but with a machine number of
diff -burN insight-6.1/bfd/elfxx-mips.c insight-6.1-psp/bfd/elfxx-mips.c
--- insight-6.1/bfd/elfxx-mips.c	2004-02-17 10:19:23.000000000 +0000
+++ insight-6.1-psp/bfd/elfxx-mips.c	2005-09-19 17:11:59.179473672 +0100
@@ -4103,6 +4103,9 @@
     case E_MIPS_MACH_SB1:
       return bfd_mach_mips_sb1;
 
+    case E_MIPS_MACH_ALLEGREX:
+      return bfd_mach_mips_allegrex;
+
     default:
       switch (flags & EF_MIPS_ARCH)
 	{
@@ -7170,6 +7173,10 @@
       val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
       break;
 
+    case bfd_mach_mips_allegrex:
+      val = E_MIPS_ARCH_2 | E_MIPS_MACH_ALLEGREX;
+      break;
+
     case bfd_mach_mipsisa32:
       val = E_MIPS_ARCH_32;
       break;
@@ -8911,6 +8918,7 @@
   /* MIPS II extensions.  */
   { bfd_mach_mips4000, bfd_mach_mips6000 },
   { bfd_mach_mipsisa32, bfd_mach_mips6000 },
+  { bfd_mach_mips_allegrex, bfd_mach_mips6000 },
 
   /* MIPS I extensions.  */
   { bfd_mach_mips6000, bfd_mach_mips3000 },
diff -burN insight-6.1/config.sub insight-6.1-psp/config.sub
--- insight-6.1/config.sub	2004-02-19 14:55:25.000000000 +0000
+++ insight-6.1-psp/config.sub	2005-09-19 17:17:10.629126128 +0100
@@ -253,6 +253,7 @@
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
+	| mipsallegrex | mipsallegrexel \
 	| mn10200 | mn10300 \
 	| msp430 \
 	| ns16k | ns32k \
@@ -326,6 +327,7 @@
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| mipsallegrex-* | mipsallegrexel-* \
 	| msp430-* \
 	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
 	| orion-* \
@@ -649,6 +651,10 @@
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	psp)
+		basic_machine=mipsallegrexel-psp
+		os=-elf
+		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
diff -burN insight-6.1/include/bin-bugs.h insight-6.1-psp/include/bin-bugs.h
--- insight-6.1/include/bin-bugs.h	2001-01-09 21:05:35.000000000 +0000
+++ insight-6.1-psp/include/bin-bugs.h	2005-09-19 17:12:41.228081312 +0100
@@ -1,3 +1,3 @@
 #ifndef REPORT_BUGS_TO
-#define REPORT_BUGS_TO	"bug-binutils@gnu.org"
+#define REPORT_BUGS_TO	"<URL:http://wiki.pspdev.org/psp:toolchain#bugs>"
 #endif
diff -burN insight-6.1/include/elf/common.h insight-6.1-psp/include/elf/common.h
--- insight-6.1/include/elf/common.h	2004-01-29 02:41:18.000000000 +0000
+++ insight-6.1-psp/include/elf/common.h	2005-09-19 17:11:59.228466224 +0100
@@ -93,6 +93,7 @@
 #define ET_HIOS		0xFEFF	/* Operating system-specific */
 #define ET_LOPROC	0xFF00	/* Processor-specific */
 #define ET_HIPROC	0xFFFF	/* Processor-specific */
+#define ET_PSPEXEC	0xFFA0	/* Sony PSP executable file */
 
 /* Values for e_machine, which identifies the architecture.  These numbers
    are officially assigned by registry@caldera.com.  See below for a list of
diff -burN insight-6.1/include/elf/mips.h insight-6.1-psp/include/elf/mips.h
--- insight-6.1/include/elf/mips.h	2003-09-30 17:17:14.000000000 +0100
+++ insight-6.1-psp/include/elf/mips.h	2005-09-19 17:11:59.239464552 +0100
@@ -189,6 +189,7 @@
 #define E_MIPS_MACH_SB1         0x008a0000
 #define E_MIPS_MACH_5400	0x00910000
 #define E_MIPS_MACH_5500	0x00980000
+#define E_MIPS_MACH_ALLEGREX 0x00A20000
 
 /* Processor specific section indices.  These sections do not actually
    exist.  Symbols with a st_shndx field corresponding to one of these
diff -burN insight-6.1/include/opcode/mips.h insight-6.1-psp/include/opcode/mips.h
--- insight-6.1/include/opcode/mips.h	2003-11-18 21:22:56.000000000 +0000
+++ insight-6.1-psp/include/opcode/mips.h	2005-09-19 17:11:59.250462880 +0100
@@ -170,6 +170,83 @@
 #define MDMX_FMTSEL_VEC_QH	0x15
 #define MDMX_FMTSEL_VEC_OB	0x16
 
+#define OP_SH_VFPU_DELTA	0
+#define OP_MASK_VFPU_DELTA	0xfffc
+#define OP_SH_VFPU_IMM3		16
+#define OP_MASK_VFPU_IMM3	0x7
+#define OP_SH_VFPU_IMM5		16
+#define OP_MASK_VFPU_IMM5	0x1f
+#define OP_SH_VFPU_IMM8		16
+#define OP_MASK_VFPU_IMM8	0xff
+#define OP_SH_VFPU_CC		18	/* Condition code. */
+#define OP_MASK_VFPU_CC		0x7
+#define OP_SH_VFPU_CONST	16
+#define OP_MASK_VFPU_CONST	0x1f
+#define OP_SH_VFPU_COND		0	/* Conditional compare. */
+#define OP_MASK_VFPU_COND	0xf
+#define OP_SH_VFPU_VMTVC	0
+#define OP_MASK_VFPU_VMTVC	0xff
+#define OP_SH_VFPU_VMFVC	8
+#define OP_MASK_VFPU_VMFVC	0xff
+#define OP_SH_VFPU_RWB		1
+#define OP_MASK_VFPU_RWB	0x1
+#define OP_SH_VFPU_ROT		16	/* Rotators used in vrot. */
+#define OP_MASK_VFPU_ROT	0x1f
+#define OP_SH_VFPU_FLOAT16	0
+#define OP_MASK_VFPU_FLOAT16	0xffff
+
+/* VFPU registers. */
+#define OP_SH_VFPU_VD		0
+#define OP_MASK_VFPU_VD		0x7f
+#define OP_SH_VFPU_VS		8
+#define OP_MASK_VFPU_VS		0x7f
+#define OP_SH_VFPU_VT		16
+#define OP_MASK_VFPU_VT		0x7f
+#define OP_SH_VFPU_VT_LO	16	/* Bits 0-4 of vt. */
+#define OP_MASK_VFPU_VT_LO	0x1f
+#define OP_SH_VFPU_VT_HI	5	/* Right-shifted. */
+#define OP_MASK_VFPU_VT_HI1	0x1	/* Bit 5 of vt. */
+#define OP_MASK_VFPU_VT_HI2	0x3	/* Bits 5-6 of vt. */
+/* Special handling of vs in vmmul instructions. */
+#define VFPU_OP_VT_VS_VD	0xff800000
+#define VFPU_OPCODE_VMMUL	0xf0000000
+
+/* VFPU prefix instruction operands.  The *_SH_* values really specify where
+   the bitfield begins, as VFPU prefix instructions have four operands
+   encoded within the immediate field. */
+#define VFPU_SH_PFX_NEG		16
+#define VFPU_MASK_PFX_NEG	0x1	/* Negation. */
+#define VFPU_SH_PFX_CST		12
+#define VFPU_MASK_PFX_CST	0x1	/* Constant. */
+#define VFPU_SH_PFX_ABS_CSTHI	8
+#define VFPU_MASK_PFX_ABS_CSTHI	0x1	/* Abs/Constant (bit 2). */
+#define VFPU_MASK_PFX_SWZ_CSTLO	0x3	/* Swizzle/Constant (bits 0-1). */
+#define VFPU_SH_PFX_MASK	8
+#define VFPU_MASK_PFX_MASK	0x1	/* Mask. */
+#define VFPU_MASK_PFX_SAT	0x3	/* Saturation. */
+
+/* Special handling of the vrot instructions. */
+#define VFPU_MASK_OP_SIZE	0x8080	/* Masks the operand size (pair, triple, quad). */
+#define VFPU_OP_SIZE_PAIR	0x80
+#define VFPU_OP_SIZE_TRIPLE	0x8000
+#define VFPU_OP_SIZE_QUAD	0x8080
+/* Note that these are within the rotators field, and not the full opcode. */
+#define VFPU_SH_ROT_HI		2
+#define VFPU_MASK_ROT_HI	0x3
+#define VFPU_SH_ROT_LO		0
+#define VFPU_MASK_ROT_LO	0x3
+#define VFPU_SH_ROT_NEG		4	/* Negation. */
+#define VFPU_MASK_ROT_NEG	0x1
+
+/* VFPU 16-bit floating-point format. */
+#define VFPU_FLOAT16_EXP_MAX	0x1f
+#define VFPU_SH_FLOAT16_SIGN	15
+#define VFPU_MASK_FLOAT16_SIGN	0x1
+#define VFPU_SH_FLOAT16_EXP	10
+#define VFPU_MASK_FLOAT16_EXP	0x1f
+#define VFPU_SH_FLOAT16_FRAC	0
+#define VFPU_MASK_FLOAT16_FRAC	0x3ff
+
 /* This structure holds information for a particular instruction.  */
 
 struct mips_opcode
@@ -255,6 +332,29 @@
 	Requires that "+A" or "+E" occur first to set position.
 	Enforces: 32 < (pos+size) <= 64.
 
+   Sony Allegrex VFPU instructions:
+   "?o"
+   "?0" - "?3"
+   "?4" - "?7"
+   "?a"
+   "?b"
+   "?c"
+   "?e"
+   "?f"
+   "?i"
+   "?q"
+   "?r"
+   "?u"
+   "?w"
+   "?d"
+   "?m"
+   "?n"
+   "?s"
+   "?t"
+   "?v"
+   "?x"
+   "?z"
+
    Floating point instructions:
    "D" 5 bit destination register (OP_*_FD)
    "M" 3 bit compare condition code (OP_*_CCC) (only used for mips4 and up)
@@ -433,6 +533,8 @@
 #define INSN_5400		  0x01000000
 /* NEC VR5500 instruction.  */
 #define INSN_5500		  0x02000000
+/* Sony Allegrex instruction.  */
+#define INSN_ALLEGREX		  0x10000000
 
 /* MIPS ISA defines, use instead of hardcoding ISA level.  */
 
@@ -479,6 +581,7 @@
 #define CPU_MIPS64      64
 #define CPU_MIPS64R2	65
 #define CPU_SB1         12310201        /* octal 'SB', 01.  */
+#define CPU_ALLEGREX    10111431        /* octal 'AL', 31.  */
 
 /* Test for membership in an ISA including chip specific ISAs.  INSN
    is pointer to an element of the opcode table; ISA is the specified
@@ -499,6 +602,7 @@
      || (cpu == CPU_VR4120 && ((insn)->membership & INSN_4120) != 0)	\
      || (cpu == CPU_VR5400 && ((insn)->membership & INSN_5400) != 0)	\
      || (cpu == CPU_VR5500 && ((insn)->membership & INSN_5500) != 0)	\
+     || (cpu == CPU_ALLEGREX && ((insn)->membership & INSN_ALLEGREX) != 0)	\
      || 0)	/* Please keep this term for easier source merging.  */
 
 /* This is a list of macro expanded instructions.
@@ -614,6 +718,16 @@
   M_LL_AB,
   M_LLD_AB,
   M_LS_A,
+  M_LVHIP,
+  M_LVHIS,
+  M_LVIP,
+  M_LVIQ,
+  M_LVIS,
+  M_LVIT,
+  M_LVLQ_AB,
+  M_LVRQ_AB,
+  M_LVQ_AB,
+  M_LVQ_AB_2,
   M_LW_A,
   M_LW_AB,
   M_LWC0_A,
@@ -703,6 +817,10 @@
   M_SUB_I,
   M_SUBU_I,
   M_SUBU_I_2,
+  M_SVLQ_AB,
+  M_SVQ_AB,
+  M_SVRQ_AB,
+  M_SVS_AB,
   M_TEQ_I,
   M_TGE_I,
   M_TGEU_I,
@@ -717,14 +835,24 @@
   M_ULH_A,
   M_ULHU,
   M_ULHU_A,
+  M_ULVQ,
+  M_ULVQ_AB,
+  M_ULVS,
   M_ULW,
   M_ULW_A,
   M_USH,
   M_USH_A,
+  M_USVQ,
+  M_USVQ_AB,
+  M_USVS,
   M_USW,
   M_USW_A,
   M_USD,
   M_USD_A,
+  M_VCMOVP,
+  M_VCMOVQ,
+  M_VCMOVS,
+  M_VCMOVT,
   M_XOR_I,
   M_COP0,
   M_COP1,
diff -burN insight-6.1/opcodes/mips-dis.c insight-6.1-psp/opcodes/mips-dis.c
--- insight-6.1/opcodes/mips-dis.c	2003-09-30 17:17:15.000000000 +0100
+++ insight-6.1-psp/opcodes/mips-dis.c	2005-09-19 17:11:59.264460752 +0100
@@ -140,6 +140,139 @@
   "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
 };
 
+static const char * const vfpu_sreg_names[128] = {
+  "S000",  "S010",  "S020",  "S030",  "S100",  "S110",  "S120",  "S130",
+  "S200",  "S210",  "S220",  "S230",  "S300",  "S310",  "S320",  "S330",
+  "S400",  "S410",  "S420",  "S430",  "S500",  "S510",  "S520",  "S530",
+  "S600",  "S610",  "S620",  "S630",  "S700",  "S710",  "S720",  "S730",
+  "S001",  "S011",  "S021",  "S031",  "S101",  "S111",  "S121",  "S131",
+  "S201",  "S211",  "S221",  "S231",  "S301",  "S311",  "S321",  "S331",
+  "S401",  "S411",  "S421",  "S431",  "S501",  "S511",  "S521",  "S531",
+  "S601",  "S611",  "S621",  "S631",  "S701",  "S711",  "S721",  "S731",
+  "S002",  "S012",  "S022",  "S032",  "S102",  "S112",  "S122",  "S132",
+  "S202",  "S212",  "S222",  "S232",  "S302",  "S312",  "S322",  "S332",
+  "S402",  "S412",  "S422",  "S432",  "S502",  "S512",  "S522",  "S532",
+  "S602",  "S612",  "S622",  "S632",  "S702",  "S712",  "S722",  "S732",
+  "S003",  "S013",  "S023",  "S033",  "S103",  "S113",  "S123",  "S133",
+  "S203",  "S213",  "S223",  "S233",  "S303",  "S313",  "S323",  "S333",
+  "S403",  "S413",  "S423",  "S433",  "S503",  "S513",  "S523",  "S533",
+  "S603",  "S613",  "S623",  "S633",  "S703",  "S713",  "S723",  "S733"
+};
+
+static const char * const vfpu_vpreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "C002",  "C012",  "C022",  "C032",  "C102",  "C112",  "C122",  "C132",
+  "C202",  "C212",  "C222",  "C232",  "C302",  "C312",  "C322",  "C332",
+  "C402",  "C412",  "C422",  "C432",  "C502",  "C512",  "C522",  "C532",
+  "C602",  "C612",  "C622",  "C632",  "C702",  "C712",  "C722",  "C732",
+  "R020",  "R021",  "R022",  "R023",  "R120",  "R121",  "R122",  "R123",
+  "R220",  "R221",  "R222",  "R223",  "R320",  "R321",  "R322",  "R323",
+  "R420",  "R421",  "R422",  "R423",  "R520",  "R521",  "R522",  "R523",
+  "R620",  "R621",  "R622",  "R623",  "R720",  "R721",  "R722",  "R723"
+};
+
+static const char * const vfpu_vtreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "C001",  "C011",  "C021",  "C031",  "C101",  "C111",  "C121",  "C131",
+  "C201",  "C211",  "C221",  "C231",  "C301",  "C311",  "C321",  "C331",
+  "C401",  "C411",  "C421",  "C431",  "C501",  "C511",  "C521",  "C531",
+  "C601",  "C611",  "C621",  "C631",  "C701",  "C711",  "C721",  "C731",
+  "R010",  "R011",  "R012",  "R013",  "R110",  "R111",  "R112",  "R113",
+  "R210",  "R211",  "R212",  "R213",  "R310",  "R311",  "R312",  "R313",
+  "R410",  "R411",  "R412",  "R413",  "R510",  "R511",  "R512",  "R513",
+  "R610",  "R611",  "R612",  "R613",  "R710",  "R711",  "R712",  "R713"
+};
+
+static const char * const vfpu_vqreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  ""
+};
+
+static const char * const vfpu_mpreg_names[128] = {
+  "M000",  "",  "M020",  "",  "M100",  "",  "M120",  "",
+  "M200",  "",  "M220",  "",  "M300",  "",  "M320",  "",
+  "M400",  "",  "M420",  "",  "M500",  "",  "M520",  "",
+  "M600",  "",  "M620",  "",  "M700",  "",  "M720",  "",
+  "E000",  "",  "E002",  "",  "E100",  "",  "E102",  "",
+  "E200",  "",  "E202",  "",  "E300",  "",  "E302",  "",
+  "E400",  "",  "E402",  "",  "E500",  "",  "E502",  "",
+  "E600",  "",  "E602",  "",  "E700",  "",  "E702",  "",
+  "M002",  "",  "M022",  "",  "M102",  "",  "M122",  "",
+  "M202",  "",  "M222",  "",  "M302",  "",  "M322",  "",
+  "M402",  "",  "M422",  "",  "M502",  "",  "M522",  "",
+  "M602",  "",  "M622",  "",  "M702",  "",  "M722",  "",
+  "E020",  "",  "E022",  "",  "E120",  "",  "E122",  "",
+  "E220",  "",  "E222",  "",  "E320",  "",  "E322",  "",
+  "E420",  "",  "E422",  "",  "E520",  "",  "E522",  "",
+  "E620",  "",  "E622",  "",  "E720",  "",  "E722",  ""
+};
+
+static const char * const vfpu_mtreg_names[128] = {
+  "M000",  "M010",  "",  "",  "M100",  "M110",  "",  "",
+  "M200",  "M210",  "",  "",  "M300",  "M310",  "",  "",
+  "M400",  "M410",  "",  "",  "M500",  "M510",  "",  "",
+  "M600",  "M610",  "",  "",  "M700",  "M710",  "",  "",
+  "E000",  "E001",  "",  "",  "E100",  "E101",  "",  "",
+  "E200",  "E201",  "",  "",  "E300",  "E301",  "",  "",
+  "E400",  "E401",  "",  "",  "E500",  "E501",  "",  "",
+  "E600",  "E601",  "",  "",  "E700",  "E701",  "",  "",
+  "M001",  "M011",  "",  "",  "M101",  "M111",  "",  "",
+  "M201",  "M211",  "",  "",  "M301",  "M311",  "",  "",
+  "M401",  "M411",  "",  "",  "M501",  "M511",  "",  "",
+  "M601",  "M611",  "",  "",  "M701",  "M711",  "",  "",
+  "E010",  "E011",  "",  "",  "E110",  "E111",  "",  "",
+  "E210",  "E211",  "",  "",  "E310",  "E311",  "",  "",
+  "E410",  "E411",  "",  "",  "E510",  "E511",  "",  "",
+  "E610",  "E611",  "",  "",  "E710",  "E711",  "",  ""
+};
+
+static const char * const vfpu_mqreg_names[128] = {
+  "M000",  "",  "",  "",  "M100",  "",  "",  "",
+  "M200",  "",  "",  "",  "M300",  "",  "",  "",
+  "M400",  "",  "",  "",  "M500",  "",  "",  "",
+  "M600",  "",  "",  "",  "M700",  "",  "",  "",
+  "E000",  "",  "",  "",  "E100",  "",  "",  "",
+  "E200",  "",  "",  "",  "E300",  "",  "",  "",
+  "E400",  "",  "",  "",  "E500",  "",  "",  "",
+  "E600",  "",  "",  "",  "E700",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  ""
+};
+
 static const struct mips_cp0sel_name mips_cp0sel_names_mips3264[] = {
   { 16, 1, "c0_config1"		},
   { 16, 2, "c0_config2"		},
@@ -288,6 +421,54 @@
   "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
 };
 
+static const char * const vfpu_cond_names[16] = {
+  "FL",  "EQ",  "LT",  "LE",  "TR",  "NE",  "GE",  "GT",
+  "EZ",  "EN",  "EI",  "ES",  "NZ",  "NN",  "NI",  "NS"
+};
+
+static const char * const vfpu_const_names[20] = {
+  "",
+  "VFPU_HUGE",
+  "VFPU_SQRT2",
+  "VFPU_SQRT1_2",
+  "VFPU_2_SQRTPI",
+  "VFPU_2_PI",
+  "VFPU_1_PI",
+  "VFPU_PI_4",
+  "VFPU_PI_2",
+  "VFPU_PI",
+  "VFPU_E",
+  "VFPU_LOG2E",
+  "VFPU_LOG10E",
+  "VFPU_LN2",
+  "VFPU_LN10",
+  "VFPU_2PI",
+  "VFPU_PI_6",
+  "VFPU_LOG10TWO",
+  "VFPU_LOG2TEN",
+  "VFPU_SQRT3_2"
+};
+
+#define VFPU_NUM_CONSTANTS \
+  ((sizeof vfpu_const_names) / (sizeof (vfpu_const_names[0])))
+const unsigned int vfpu_num_constants = VFPU_NUM_CONSTANTS;
+
+static const char * const vfpu_rwb_names[4] = {
+  "wt",  "wb",  "",  ""
+};
+
+static const char * const pfx_cst_names[8] = {
+  "0",  "1",  "2",  "1/2",  "3",  "1/3",  "1/4",  "1/6"
+};
+
+static const char * const pfx_swz_names[4] = {
+  "x",  "y",  "z",  "w"
+};
+
+static const char * const pfx_sat_names[4] = {
+  "",  "[0:1]",  "",  "[-1:1]"
+};
+
 struct mips_abi_choice {
   const char *name;
   const char * const *gpr_names;
@@ -359,6 +540,8 @@
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
   { "mips5",	1, bfd_mach_mips5, CPU_MIPS5, ISA_MIPS5,
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
+  { "allegrex", 1, bfd_mach_mips_allegrex, CPU_ALLEGREX, ISA_MIPS2,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
 
   /* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.
      Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
@@ -1020,6 +1203,349 @@
 				 (l >> OP_SH_FT) & OP_MASK_FT);
 	  break;
 
+	case '?':
+	  /* VFPU extensions.  */
+	  d++;
+	  switch (*d)
+	    {
+	    case '\0':
+	      /* xgettext:c-format */
+	      (*info->fprintf_func) (info->stream,
+				     _("# internal error, incomplete VFPU extension sequence (?)"));
+	      return;
+
+	    case 'o':
+	      delta = (l >> OP_SH_VFPU_DELTA) & OP_MASK_VFPU_DELTA;
+	      if (delta & 0x8000)
+		delta |= ~0xffff;
+	      (*info->fprintf_func) (info->stream, "%d",
+				     delta);
+	      break;
+
+	    case '0':
+	    case '1':
+	    case '2':
+	    case '3':
+	      {
+		unsigned int pos = *d, base = '0';
+		unsigned int negation = (l >> (pos - (base - VFPU_SH_PFX_NEG))) & VFPU_MASK_PFX_NEG;
+		unsigned int constant = (l >> (pos - (base - VFPU_SH_PFX_CST))) & VFPU_MASK_PFX_CST;
+		unsigned int abs_consthi =
+		    (l >> (pos - (base - VFPU_SH_PFX_ABS_CSTHI))) & VFPU_MASK_PFX_ABS_CSTHI;
+		unsigned int swz_constlo = (l >> ((pos - base) * 2)) & VFPU_MASK_PFX_SWZ_CSTLO;
+
+		if (negation)
+		  (*info->fprintf_func) (info->stream, "-");
+		if (constant)
+		  {
+		    (*info->fprintf_func) (info->stream, "%s",
+                                           pfx_cst_names[(abs_consthi << 2) | swz_constlo]);
+		  }
+		else
+		  {
+		    if (abs_consthi)
+		      (*info->fprintf_func) (info->stream, "|%s|",
+					     pfx_swz_names[swz_constlo]);
+		    else
+		      (*info->fprintf_func) (info->stream, "%s",
+					     pfx_swz_names[swz_constlo]);
+		  }
+	      }
+	      break;
+
+	    case '4':
+	    case '5':
+	    case '6':
+	    case '7':
+	      {
+		unsigned int pos = *d, base = '4';
+		unsigned int mask = (l >> (pos - (base - VFPU_MASK_PFX_MASK))) & VFPU_MASK_PFX_MASK;
+		unsigned int saturation = (l >> ((pos - base) * 2)) & VFPU_MASK_PFX_SAT;
+
+		if (mask)
+		  (*info->fprintf_func) (info->stream, "m");
+		else
+		  (*info->fprintf_func) (info->stream, "%s",
+                                         pfx_sat_names[saturation]);
+	      }
+	      break;
+
+	    case 'a':
+	      {
+		unsigned int c = (l >> OP_SH_VFPU_CONST) & OP_MASK_VFPU_CONST;
+		if (c < vfpu_num_constants)
+		  {
+		    (*info->fprintf_func) (info->stream, "%s",
+					   vfpu_const_names[c]);
+		  }
+		break;
+	      }
+
+	    case 'b':
+	      /* 5-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_IMM5) & OP_MASK_VFPU_IMM5);
+	      break;
+
+	    case 'c':
+	      /* VFPU condition code.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_CC) & OP_MASK_VFPU_CC);
+	      break;
+
+	    case 'e':
+	      /* 3-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_IMM3) & OP_MASK_VFPU_IMM3);
+	      break;
+
+	    case 'f':
+	      /* Conditional compare.  */
+	      (*info->fprintf_func) (info->stream, "%s",
+				     vfpu_cond_names[(l >> OP_SH_VFPU_COND) & OP_MASK_VFPU_COND]);
+	      /* Apparently this specifier is unused.  */
+	      d++;
+	      break;
+
+	    case 'i':
+	      /* 8-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "0x%02x",
+				     (l >> OP_SH_VFPU_IMM8) & OP_MASK_VFPU_IMM8);
+	      break;
+
+	    case 'q':
+	      /* VFPU control register (vmtvc).  */
+	      (*info->fprintf_func) (info->stream, "$%d",
+				     (l >> OP_SH_VFPU_VMTVC) & OP_MASK_VFPU_VMTVC);
+	      break;
+
+	    case 'r':
+	      /* VFPU control register (vmfvc).  */
+	      (*info->fprintf_func) (info->stream, "$%d",
+				     (l >> OP_SH_VFPU_VMFVC) & OP_MASK_VFPU_VMFVC);
+	      break;
+
+	    case 'u':
+	      /* Convert a VFPU 16-bit floating-point number to IEEE754. */
+	      {
+		union float2int {
+			unsigned int i;
+			float f;
+		} float2int;
+		unsigned short float16 = (l >> OP_SH_VFPU_FLOAT16) & OP_MASK_VFPU_FLOAT16;
+		unsigned int sign = (float16 >> VFPU_SH_FLOAT16_SIGN) & VFPU_MASK_FLOAT16_SIGN;
+		int exponent = (float16 >> VFPU_SH_FLOAT16_EXP) & VFPU_MASK_FLOAT16_EXP;
+		unsigned int fraction = float16 & VFPU_MASK_FLOAT16_FRAC;
+		char signchar = '+' + ((sign == 1) * 2);
+
+		if (exponent == VFPU_FLOAT16_EXP_MAX)
+		  {
+		    if (fraction == 0)
+		      (*info->fprintf_func) (info->stream, "%cInf", signchar);
+		    else
+		      (*info->fprintf_func) (info->stream, "%cNaN", signchar);
+		  }
+		else if (exponent == 0 && fraction == 0)
+		  {
+		    (*info->fprintf_func) (info->stream, "%c0", signchar);
+		  }
+		else
+		  {
+		    if (exponent == 0)
+		      {
+			do
+			  {
+			    fraction <<= 1;
+			    exponent--;
+			  }
+			while (!(fraction & (VFPU_MASK_FLOAT16_FRAC + 1)));
+
+			fraction &= VFPU_MASK_FLOAT16_FRAC;
+		      }
+
+		    /* Convert to 32-bit single-precision IEEE754. */
+		    float2int.i = sign << 31;
+		    float2int.i |= (exponent + 112) << 23;
+		    float2int.i |= fraction << 13;
+		    (*info->fprintf_func) (info->stream, "%g", float2int.f);
+		  }
+	      }
+	      break;
+
+	    case 'w':
+	      {
+		const char *elements[4];
+		unsigned int opcode = l & VFPU_MASK_OP_SIZE;
+		unsigned int rotators = (l >> OP_SH_VFPU_ROT) & OP_MASK_VFPU_ROT;
+		unsigned int opsize, rothi, rotlo, negation, i;
+
+		/* Determine the operand size so we'll know how many elements to output. */
+		if (opcode == VFPU_OP_SIZE_PAIR)
+		  opsize = 2;
+		else if (opcode == VFPU_OP_SIZE_TRIPLE)
+		  opsize = 3;
+		else
+		  opsize = (opcode == VFPU_OP_SIZE_QUAD) * 4;	/* Sanity check. */
+
+		rothi = (rotators >> VFPU_SH_ROT_HI) & VFPU_MASK_ROT_HI;
+		rotlo = (rotators >> VFPU_SH_ROT_LO) & VFPU_MASK_ROT_LO;
+		negation = (rotators >> VFPU_SH_ROT_NEG) & VFPU_MASK_ROT_NEG;
+
+		if (rothi == rotlo)
+		  {
+		    if (negation)
+		      {
+			elements[0] = "-s";
+			elements[1] = "-s";
+			elements[2] = "-s";
+			elements[3] = "-s";
+		      }
+		    else
+		      {
+			elements[0] = "s";
+			elements[1] = "s";
+			elements[2] = "s";
+			elements[3] = "s";
+		      }
+		  }
+		else
+		  {
+		    elements[0] = "0";
+		    elements[1] = "0";
+		    elements[2] = "0";
+		    elements[3] = "0";
+		  }
+		if (negation)
+		  elements[rothi] = "-s";
+		else
+		  elements[rothi] = "s";
+		elements[rotlo] = "c";
+
+		(*info->fprintf_func) (info->stream, "[");
+		i = 0;
+		for (;;)
+		  {
+		    (*info->fprintf_func) (info->stream, "%s",
+					   elements[i++]);
+		    if (i >= opsize)
+		      break;
+		    (*info->fprintf_func) (info->stream, ",");
+		  }
+		(*info->fprintf_func) (info->stream, "]");
+	      }
+	      break;
+
+	    case 'd':
+	    case 'm':
+	    case 'n':
+	    case 's':
+	    case 't':
+	    case 'v':
+	    case 'x':
+	      {
+		unsigned int vreg = 0;
+
+		/* The first char specifies the bitfield that contains the register number. */
+		switch (*d)
+		  {
+		  case 'd':
+		  case 'v':
+		  case 'x':
+		    vreg = (l >> OP_SH_VFPU_VD) & OP_MASK_VFPU_VD;
+		    break;
+
+		  case 'm':
+		    /* Combine bits 0-4 of vt with bits 5-6 of vt. */
+		    vreg = ((l >> OP_SH_VFPU_VT_LO) & OP_MASK_VFPU_VT_LO)
+			    | ((l & OP_MASK_VFPU_VT_HI2) << OP_SH_VFPU_VT_HI);
+		    break;
+
+		  case 'n':
+		    /* Combine bits 0-4 of vt with bit 5 of vt. */
+		    vreg = ((l >> OP_SH_VFPU_VT_LO) & OP_MASK_VFPU_VT_LO)
+			    | ((l & OP_MASK_VFPU_VT_HI1) << OP_SH_VFPU_VT_HI);
+		    break;
+
+		  case 's':
+		    {
+			unsigned int temp_vreg = l >> OP_SH_VFPU_VS;
+
+			vreg = temp_vreg & OP_MASK_VFPU_VS;
+			if ((l & VFPU_OP_VT_VS_VD) == VFPU_OPCODE_VMMUL)
+			  {
+			    /* vmmul instructions have the RXC bit (bit 13) inverted. */
+			    if (temp_vreg & 0x20)
+			      vreg = temp_vreg & 0x5f;
+			    else
+			      vreg |= 0x20;
+			  }
+		    }
+		    break;
+
+		  case 't':
+		    vreg = (l >> OP_SH_VFPU_VT) & OP_MASK_VFPU_VT;
+		    break;
+		  }
+
+		/* The next char is the register set vreg comes from. */
+		d++;
+		switch (*d)
+		  {
+		  case '0':
+		    (*info->fprintf_func) (info->stream, "%s.s",
+					   vfpu_sreg_names[vreg]);
+		    break;
+
+		  case '1':
+		    (*info->fprintf_func) (info->stream, "%s.p",
+					   vfpu_vpreg_names[vreg]);
+		    break;
+
+		  case '2':
+		    (*info->fprintf_func) (info->stream, "%s.t",
+					   vfpu_vtreg_names[vreg]);
+		    break;
+
+		  case '3':
+		    (*info->fprintf_func) (info->stream, "%s.q",
+					   vfpu_vqreg_names[vreg]);
+		    break;
+
+		  case '5':
+		    (*info->fprintf_func) (info->stream, "%s.p",
+					   vfpu_mpreg_names[vreg]);
+		    break;
+
+		  case '6':
+		    (*info->fprintf_func) (info->stream, "%s.t",
+					   vfpu_mtreg_names[vreg]);
+		    break;
+
+		  case '7':
+		    (*info->fprintf_func) (info->stream, "%s.q",
+					   vfpu_mqreg_names[vreg]);
+		    break;
+
+		  default:
+		    /* xgettext:c-format */
+		    (*info->fprintf_func) (info->stream,
+					   _("# internal error, undefined vreg modifier(%c)"),
+					   *d);
+		    break;
+		  }
+
+		/* The last char is unused for disassembly. */
+		d++;
+	      }
+	      break;
+
+	    case 'z':
+	      (*info->fprintf_func) (info->stream, "%s",
+				     vfpu_rwb_names[(l >> OP_SH_VFPU_RWB) & OP_MASK_VFPU_RWB]);
+	      break;
+	    }
+	  break;
+
 	default:
 	  /* xgettext:c-format */
 	  (*info->fprintf_func) (info->stream,
diff -burN insight-6.1/opcodes/mips-opc.c insight-6.1-psp/opcodes/mips-opc.c
--- insight-6.1/opcodes/mips-opc.c	2003-11-18 21:22:57.000000000 +0000
+++ insight-6.1-psp/opcodes/mips-opc.c	2005-09-19 17:16:15.596492360 +0100
@@ -109,6 +109,7 @@
 #define N5	(INSN_5400 | INSN_5500)
 #define N54	INSN_5400
 #define N55	INSN_5500
+#define AL	INSN_ALLEGREX
 
 #define G1      (T3             \
                  )
@@ -436,7 +437,7 @@
 {"cabs.un.d",  "M,S,T",	0x46200071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_D,	M3D	},
 {"cabs.un.ps", "M,S,T",	0x46c00071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_D,	M3D	},
 {"cabs.un.s",  "M,S,T",	0x46000071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_S,	M3D	},
-{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	I3|I32|T3},
+{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	I3|I32|T3|AL},
 {"ceil.l.d", "D,S",	0x4620000a, 0xffff003f, WR_D|RD_S|FP_D,		I3	},
 {"ceil.l.s", "D,S",	0x4600000a, 0xffff003f, WR_D|RD_S|FP_S,		I3	},
 {"ceil.w.d", "D,S",	0x4620000e, 0xffff003f, WR_D|RD_S|FP_D,		I2	},
@@ -447,7 +448,9 @@
 {"cfc2",    "t,G",	0x48400000, 0xffe007ff,	LCD|WR_t|RD_C2,		I1	},
 {"cfc3",    "t,G",	0x4c400000, 0xffe007ff,	LCD|WR_t|RD_C3,		I1	},
 {"clo",     "U,s",      0x70000021, 0xfc0007ff, WR_d|WR_t|RD_s, 	I32|N55 },
+{"clo",     "d,s",      0x00000017, 0xfc1f07ff, WR_d|RD_s,      			AL	},
 {"clz",     "U,s",      0x70000020, 0xfc0007ff, WR_d|WR_t|RD_s, 	I32|N55 },
+{"clz",     "d,s",      0x00000016, 0xfc1f07ff, WR_d|RD_s,                            AL      },
 {"ctc0",    "t,G",	0x40c00000, 0xffe007ff,	COD|RD_t|WR_CC,		I1	},
 {"ctc1",    "t,G",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	I1	},
 {"ctc1",    "t,S",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	I1	},
@@ -469,10 +472,12 @@
 {"cvt.ps.s","D,V,T",	0x46000026, 0xffe0003f,	WR_D|RD_S|RD_T|FP_D,	I5	},
 {"cvt.pw.ps", "D,S",	0x46c00024, 0xffff003f,	WR_D|RD_S|FP_S|FP_D,	M3D	},
 {"dabs",    "d,v",	0,    (int) M_DABS,	INSN_MACRO,		I3	},
+{"max",     "d,v,t",    0x0000002c, 0xfc0007ff, WR_d|RD_s|RD_t,                       AL	},
 {"dadd",    "d,v,t",	0x0000002c, 0xfc0007ff, WR_d|RD_s|RD_t,		I3	},
 {"dadd",    "t,r,I",	0,    (int) M_DADD_I,	INSN_MACRO,		I3	},
 {"daddi",   "t,r,j",	0x60000000, 0xfc000000, WR_t|RD_s,		I3	},
 {"daddiu",  "t,r,j",	0x64000000, 0xfc000000, WR_t|RD_s,		I3	},
+{"min",     "d,v,t",    0x0000002d, 0xfc0007ff, WR_d|RD_s|RD_t,                      AL	},
 {"daddu",   "d,v,t",	0x0000002d, 0xfc0007ff, WR_d|RD_s|RD_t,		I3	},
 {"daddu",   "t,r,I",	0,    (int) M_DADDU_I,	INSN_MACRO,		I3	},
 {"dbreak",  "",		0x7000003f, 0xffffffff,	0,			N5	},
@@ -601,8 +606,8 @@
 {"dsubu",   "d,v,I",	0,    (int) M_DSUBU_I,	INSN_MACRO,		I3	},
 {"ei",      "",		0x41606020, 0xffffffff,	WR_t|WR_C0,		I33	},
 {"ei",      "t",	0x41606020, 0xffe0ffff,	WR_t|WR_C0,		I33	},
-{"eret",    "",         0x42000018, 0xffffffff, 0,      		I3|I32	},
-{"ext",     "t,r,+A,+C", 0x7c000000, 0xfc00003f, WR_t|RD_s,    		I33	},
+{"eret",    "",         0x42000018, 0xffffffff, 0,      				I3|I32|AL	},
+{"ext",     "t,r,+A,+C", 0x7c000000, 0xfc00003f, WR_t|RD_s,    				I33|AL	},
 {"floor.l.d", "D,S",	0x4620000b, 0xffff003f, WR_D|RD_S|FP_D,		I3	},
 {"floor.l.s", "D,S",	0x4600000b, 0xffff003f, WR_D|RD_S|FP_S,		I3	},
 {"floor.w.d", "D,S",	0x4620000f, 0xffff003f, WR_D|RD_S|FP_D,		I2	},
@@ -611,7 +616,7 @@
 {"flushd",  "",		0xbc020000, 0xffffffff, 0, 			L1	},
 {"flushid", "",		0xbc030000, 0xffffffff, 0, 			L1	},
 {"hibernate","",        0x42000023, 0xffffffff,	0, 			V1	},
-{"ins",     "t,r,+A,+B", 0x7c000004, 0xfc00003f, WR_t|RD_s,    		I33	},
+{"ins",     "t,r,+A,+B", 0x7c000004, 0xfc00003f, WR_t|RD_s,    				I33|AL	},
 {"jr",      "s",	0x00000008, 0xfc1fffff,	UBD|RD_s,		I1	},
 {"jr.hb",   "s",	0x00000408, 0xfc1fffff,	UBD|RD_s,		I33	},
 {"j",       "s",	0x00000008, 0xfc1fffff,	UBD|RD_s,		I1	}, /* jr */
@@ -645,18 +650,7 @@
 {"ld",	    "t,o(b)",   0xdc000000, 0xfc000000, WR_t|RD_b,		I3	},
 {"ld",      "t,o(b)",	0,    (int) M_LD_OB,	INSN_MACRO,		I1	},
 {"ld",      "t,A(b)",	0,    (int) M_LD_AB,	INSN_MACRO,		I1	},
-{"ldc1",    "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	I2	},
-{"ldc1",    "E,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	I2	},
-{"ldc1",    "T,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		I2	},
-{"ldc1",    "E,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		I2	},
-{"l.d",     "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	I2	}, /* ldc1 */
-{"l.d",     "T,o(b)",	0,    (int) M_L_DOB,	INSN_MACRO,		I1	},
-{"l.d",     "T,A(b)",	0,    (int) M_L_DAB,	INSN_MACRO,		I1	},
-{"ldc2",    "E,o(b)",	0xd8000000, 0xfc000000, CLD|RD_b|WR_CC,		I2	},
-{"ldc2",    "E,A(b)",	0,    (int) M_LDC2_AB,	INSN_MACRO,		I2	},
-{"ldc3",    "E,o(b)",	0xdc000000, 0xfc000000, CLD|RD_b|WR_CC,		I2	},
-{"ldc3",    "E,A(b)",	0,    (int) M_LDC3_AB,	INSN_MACRO,		I2	},
-{"ldl",	    "t,o(b)",	0x68000000, 0xfc000000, LDD|WR_t|RD_b,		I3	},
+{"ldl",	    "t,o(b)",	0x68000000, 0xfc000000, LDD|WR_t|RD_b,		I3|AL	},
 {"ldl",	    "t,A(b)",	0,    (int) M_LDL_AB,	INSN_MACRO,		I3	},
 {"ldr",	    "t,o(b)",	0x6c000000, 0xfc000000, LDD|WR_t|RD_b,		I3	},
 {"ldr",     "t,A(b)",	0,    (int) M_LDR_AB,	INSN_MACRO,		I3	},
@@ -686,8 +680,6 @@
 {"lwc1",    "E,A(b)",	0,    (int) M_LWC1_AB,	INSN_MACRO,		I1	},
 {"l.s",     "T,o(b)",	0xc4000000, 0xfc000000,	CLD|RD_b|WR_T|FP_S,	I1	}, /* lwc1 */
 {"l.s",     "T,A(b)",	0,    (int) M_LWC1_AB,	INSN_MACRO,		I1	},
-{"lwc2",    "E,o(b)",	0xc8000000, 0xfc000000,	CLD|RD_b|WR_CC,		I1	},
-{"lwc2",    "E,A(b)",	0,    (int) M_LWC2_AB,	INSN_MACRO,		I1	},
 {"lwc3",    "E,o(b)",	0xcc000000, 0xfc000000,	CLD|RD_b|WR_CC,		I1	},
 {"lwc3",    "E,A(b)",	0,    (int) M_LWC3_AB,	INSN_MACRO,		I1	},
 {"lwl",     "t,o(b)",	0x88000000, 0xfc000000,	LDD|RD_b|WR_t,		I1	},
@@ -719,10 +711,12 @@
 {"madd.s",  "D,R,S,T",	0x4c000020, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_S,    I4	},
 {"madd.ps", "D,R,S,T",	0x4c000026, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_D,    I5	},
 {"madd",    "s,t",      0x0000001c, 0xfc00ffff, RD_s|RD_t|WR_HILO,           L1 },
+{"madd",    "s,t",      0x0000001c, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,               AL	},
 {"madd",    "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|MOD_HILO,          I32|N55},
 {"madd",    "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      G1 },
 {"madd",    "d,s,t",    0x70000000, 0xfc0007ff, RD_s|RD_t|WR_HILO|WR_d|IS_M, G1 },
 {"maddu",   "s,t",      0x0000001d, 0xfc00ffff, RD_s|RD_t|WR_HILO,           L1 },
+{"maddu",   "s,t",      0x0000001d, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,               AL	},
 {"maddu",   "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|MOD_HILO,          I32|N55},
 {"maddu",   "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      G1	},
 {"maddu",   "d,s,t",    0x70000001, 0xfc0007ff, RD_s|RD_t|WR_HILO|WR_d|IS_M, G1	},
@@ -763,7 +757,7 @@
 {"movf.l",  "X,Y,N",	0x46a00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	MX|SB1	},
 {"movf.s",  "D,S,N",    0x46000011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   I4|I32	},
 {"movf.ps", "D,S,N",	0x46c00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	I5	},
-{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	I4|I32	},
+{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 			I4|I32|AL	},
 {"ffc",     "d,v",	0x0000000b, 0xfc1f07ff,	WR_d|RD_s,		L1	},
 {"movn.d",  "D,S,t",    0x46200013, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    I4|I32	},
 {"movn.l",  "D,S,t",    0x46a00013, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    MX|SB1	},
@@ -776,7 +770,7 @@
 {"movt.l",  "X,Y,N",    0x46a10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,   MX|SB1	},
 {"movt.s",  "D,S,N",    0x46010011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   I4|I32	},
 {"movt.ps", "D,S,N",	0x46c10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	I5	},
-{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 	I4|I32	},
+{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 			I4|I32|AL	},
 {"ffs",     "d,v",	0x0000000a, 0xfc1f07ff,	WR_d|RD_s,		L1	},
 {"movz.d",  "D,S,t",    0x46200012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    I4|I32	},
 {"movz.l",  "D,S,t",    0x46a00012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    MX|SB1	},
@@ -793,8 +787,10 @@
 {"msub.s",  "D,R,S,T",	0x4c000028, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_S, I4	},
 {"msub.ps", "D,R,S,T",	0x4c00002e, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_D, I5	},
 {"msub",    "s,t",      0x0000001e, 0xfc00ffff, RD_s|RD_t|WR_HILO,	L1    	},
+{"msub",    "s,t",      0x0000002e, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,               AL	},
 {"msub",    "s,t",      0x70000004, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     I32|N55 },
 {"msubu",   "s,t",      0x0000001f, 0xfc00ffff, RD_s|RD_t|WR_HILO,	L1	},
+{"msubu",   "s,t",      0x0000002f, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,               AL	},
 {"msubu",   "s,t",      0x70000005, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     I32|N55	},
 {"mtpc",    "t,P",	0x4080c801, 0xffe0ffc1,	COD|RD_t|WR_C0,		M1|N5	},
 {"mtps",    "t,P",	0x4080c800, 0xffe0ffc1,	COD|RD_t|WR_C0,		M1|N5	},
@@ -944,13 +940,13 @@
 {"rol",     "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		I1	},
 {"ror",     "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		I1	},
 {"ror",     "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		I1	},
-{"ror",	    "d,w,<",	0x00200002, 0xffe0003f,	WR_d|RD_t,		N5|I33	},
-{"rorv",    "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		N5|I33	},
-{"rotl",    "d,v,t",	0,    (int) M_ROL,	INSN_MACRO,		I33	},
-{"rotl",    "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		I33	},
-{"rotr",    "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		I33	},
-{"rotr",    "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		I33	},
-{"rotrv",   "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		I33	},
+{"ror",	    "d,w,<",	0x00200002, 0xffe0003f,	WR_d|RD_t,				N5|I33|AL	},
+{"rorv",    "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,				N5|I33|AL	},
+{"rotl",    "d,v,t",	0,    (int) M_ROL,	INSN_MACRO,				I33|AL	},
+{"rotl",    "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,			I33|AL	},
+{"rotr",    "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,				I33|AL	},
+{"rotr",    "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,				I33|AL	},
+{"rotrv",   "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,				I33|AL	},
 {"round.l.d", "D,S",	0x46200008, 0xffff003f, WR_D|RD_S|FP_D,		I3	},
 {"round.l.s", "D,S",	0x46000008, 0xffff003f, WR_D|RD_S|FP_S,		I3	},
 {"round.w.d", "D,S",	0x4620000c, 0xffff003f, WR_D|RD_S|FP_D,		I2	},
@@ -982,24 +978,13 @@
 {"sdbbp",   "c,q",	0x0000000e, 0xfc00003f,	TRAP,			G2	},
 {"sdbbp",   "",         0x7000003f, 0xffffffff, TRAP,           	I32     },
 {"sdbbp",   "B",        0x7000003f, 0xfc00003f, TRAP,           	I32     },
-{"sdc1",    "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	I2	},
-{"sdc1",    "E,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	I2	},
-{"sdc1",    "T,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		I2	},
-{"sdc1",    "E,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		I2	},
-{"sdc2",    "E,o(b)",	0xf8000000, 0xfc000000, SM|RD_C2|RD_b,		I2	},
-{"sdc2",    "E,A(b)",	0,    (int) M_SDC2_AB,	INSN_MACRO,		I2	},
-{"sdc3",    "E,o(b)",	0xfc000000, 0xfc000000, SM|RD_C3|RD_b,		I2	},
-{"sdc3",    "E,A(b)",	0,    (int) M_SDC3_AB,	INSN_MACRO,		I2	},
-{"s.d",     "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	I2	},
-{"s.d",     "T,o(b)",	0,    (int) M_S_DOB,	INSN_MACRO,		I1	},
-{"s.d",     "T,A(b)",	0,    (int) M_S_DAB,	INSN_MACRO,		I1	},
-{"sdl",     "t,o(b)",	0xb0000000, 0xfc000000,	SM|RD_t|RD_b,		I3	},
+{"sdl",     "t,o(b)",	0xb0000000, 0xfc000000,	SM|RD_t|RD_b,		I3|AL	},
 {"sdl",     "t,A(b)",	0,    (int) M_SDL_AB,	INSN_MACRO,		I3	},
 {"sdr",     "t,o(b)",	0xb4000000, 0xfc000000,	SM|RD_t|RD_b,		I3	},
 {"sdr",     "t,A(b)",	0,    (int) M_SDR_AB,	INSN_MACRO,		I3	},
 {"sdxc1",   "S,t(b)",   0x4c000009, 0xfc0007ff, SM|RD_S|RD_t|RD_b,	I4	},
-{"seb",     "d,w",	0x7c000420, 0xffe007ff,	WR_d|RD_t,		I33	},
-{"seh",     "d,w",	0x7c000620, 0xffe007ff,	WR_d|RD_t,		I33	},
+{"seb",     "d,w",	0x7c000420, 0xffe007ff,	WR_d|RD_t,		I33|AL	},
+{"seh",     "d,w",	0x7c000620, 0xffe007ff,	WR_d|RD_t,		I33|AL},
 {"selsl",   "d,v,t",	0x00000005, 0xfc0007ff,	WR_d|RD_s|RD_t,		L1	},
 {"selsr",   "d,v,t",	0x00000001, 0xfc0007ff,	WR_d|RD_s|RD_t,		L1	},
 {"seq",     "d,v,t",	0,    (int) M_SEQ,	INSN_MACRO,		I1	},
@@ -1091,8 +1076,6 @@
 {"swc1",    "E,A(b)",	0,    (int) M_SWC1_AB,	INSN_MACRO,		I1	},
 {"s.s",     "T,o(b)",	0xe4000000, 0xfc000000,	SM|RD_T|RD_b|FP_S,	I1	}, /* swc1 */
 {"s.s",     "T,A(b)",	0,    (int) M_SWC1_AB,	INSN_MACRO,		I1	},
-{"swc2",    "E,o(b)",	0xe8000000, 0xfc000000,	SM|RD_C2|RD_b,		I1	},
-{"swc2",    "E,A(b)",	0,    (int) M_SWC2_AB,	INSN_MACRO,		I1	},
 {"swc3",    "E,o(b)",	0xec000000, 0xfc000000,	SM|RD_C3|RD_b,		I1	},
 {"swc3",    "E,A(b)",	0,    (int) M_SWC3_AB,	INSN_MACRO,		I1	},
 {"swl",     "t,o(b)",	0xa8000000, 0xfc000000,	SM|RD_t|RD_b,		I1	},
@@ -1177,7 +1160,8 @@
 {"waiti",   "",		0x42000020, 0xffffffff,	TRAP,			L1	},
 {"wb", 	    "o(b)",	0xbc040000, 0xfc1f0000, SM|RD_b,		L1	},
 {"wrpgpr",  "d,w",	0x41c00000, 0xffe007ff, RD_t,			I33	},
-{"wsbh",    "d,w",	0x7c0000a0, 0xffe007ff,	WR_d|RD_t,		I33	},
+{"wsbh",    "d,w",	0x7c0000a0, 0xffe007ff,	WR_d|RD_t,				I33|AL	},
+{"wsbw",    "d,t",	0x7c0000e0, 0xffe007ff, WR_d|RD_t,				AL	},
 {"xor",     "d,v,t",	0x00000026, 0xfc0007ff,	WR_d|RD_s|RD_t,		I1	},
 {"xor",     "t,r,I",	0,    (int) M_XOR_I,	INSN_MACRO,		I1	},
 {"xor.ob",  "X,Y,Q",	0x7800000d, 0xfc20003f,	WR_D|RD_S|RD_T|FP_D,	MX|SB1	},
@@ -1187,6 +1171,347 @@
 {"xor.qh",  "X,Y,Q",	0x7820000d, 0xfc20003f,	WR_D|RD_S|RD_T|FP_D,	MX	},
 {"xori",    "t,r,i",	0x38000000, 0xfc000000,	WR_t|RD_s,		I1	},
 
+/* Sony Allegrex CPU core.  */
+{"bitrev",  "d,t",      0x7c000520, 0xffe007ff, WR_d|RD_t,                            AL	},
+
+/* Sony Allegrex VFPU instructions.  */
+{"bvf",     "?c,p",		0x49000000, 0xffe30000, CBD|RD_CC,			AL	},
+{"bvfl",    "?c,p",		0x49020000, 0xffe30000, CBL|RD_CC,			AL	},
+{"bvt",     "?c,p",		0x49010000, 0xffe30000, CBD|RD_CC,			AL	},
+{"bvtl",    "?c,p",		0x49030000, 0xffe30000, CBL|RD_CC,			AL	},
+{"lv.s",    "?m0x,?o(b)",	0xc8000000, 0xfc000000, CLD|RD_s|WR_CC,			AL	},
+{"lv.s",    "?m0x,A(b)",	0,    (int) M_LVQ_AB,	INSN_MACRO,			AL	},
+{"ulv.s",   "?m0x,o(b)",	0,    (int) M_ULVS,	INSN_MACRO,			AL	},
+{"lv.q",    "?n3x,?o(b)",	0xd8000000, 0xfc000002, CLD|RD_s|WR_CC,			AL	},
+{"lv.q",    "?n3x,A(b)",	0,    (int) M_LVQ_AB_2,	INSN_MACRO,			AL	},
+{"ulv.q",   "?n3x,?o(b)",	0,    (int) M_ULVQ,	INSN_MACRO,			AL	},
+{"ulv.q",   "?n3x,A(b)",	0,    (int) M_ULVQ_AB,	INSN_MACRO,			AL	},
+{"lvi.s",   "?t0x,l?y0",	0,    (int) M_LVIS,	INSN_MACRO,			AL	},
+{"lvi.p",   "?t1x,?[l?y0,l?y1?]", 0,  (int) M_LVIP,	INSN_MACRO,			AL	},
+{"lvi.t",   "?t2x,?[l?y0,l?y1,l?y2?]", 0, (int) M_LVIT,	INSN_MACRO,			AL	},
+{"lvi.q",   "?t3x,?[l?y0,l?y1,l?y2,l?y3?]", 0, (int) M_LVIQ,	INSN_MACRO,		AL	},
+{"lvhi.s",  "?t0x,?[?u?y0,?u?y1?]", 0, (int) M_LVHIS,	INSN_MACRO,			AL	},
+{"lvhi.p",  "?t1x,?[?u?y0,?u?y1,?u?y2,?u?y3?]", 0, (int) M_LVHIP,	INSN_MACRO, 	AL	},
+{"sv.s",    "?m0x,?o(b)",	0xe8000000, 0xfc000000, SM|RD_s|RD_C2,			AL	},
+{"sv.s",    "?m0x,A(b)",	0,    (int) M_SVS_AB,	INSN_MACRO,			AL	},
+{"usv.s",   "?m0x,o(b)",	0,    (int) M_USVS,	INSN_MACRO,			AL	},
+{"sv.q",    "?n3x,?o(b)",	0xf8000000, 0xfc000002, SM|RD_s|RD_C2,			AL	},
+{"sv.q",    "?n3x,?o(b),?z",	0xf8000000, 0xfc000000, SM|RD_s|RD_C2,			AL	},
+{"sv.q",    "?n3x,A(b)",	0,    (int) M_SVQ_AB,	INSN_MACRO,			AL	},
+{"sv.q",    "?n3x,A(b),?z",	0,    (int) M_SVQ_AB,	INSN_MACRO,			AL	},
+{"sv.q",    "?n3x,A,?z",	0,    (int) M_SVQ_AB,	INSN_MACRO,			AL	},
+{"usv.q",   "?n3x,?o(b)",	0,    (int) M_USVQ,	INSN_MACRO,			AL	},
+{"usv.q",   "?n3x,A(b)",	0,    (int) M_USVQ_AB,	INSN_MACRO,			AL	},
+{"vwb.q",   "?n3x,?o(b)",	0xf8000002, 0xfc000002, SM|RD_s|RD_C2,			AL	},
+{"lvl.q",   "?n3x,?o(b)",	0xd4000000, 0xfc000002, CLD|RD_s|WR_CC,			AL	},
+{"lvl.q",   "?n3x,A(b)",	0,    (int) M_LVLQ_AB,	INSN_MACRO,			AL	},
+{"lvr.q",   "?n3x,?o(b)",	0xd4000002, 0xfc000002, CLD|RD_s|WR_CC,			AL	},
+{"lvr.q",   "?n3x,A(b)",	0,    (int) M_LVRQ_AB,	INSN_MACRO,			AL	},
+{"svl.q",   "?n3x,?o(b)",	0xf4000000, 0xfc000002, SM|RD_s|RD_C2,			AL	},
+{"svl.q",   "?n3x,A(b)",	0,    (int) M_SVLQ_AB,	INSN_MACRO,			AL	},
+{"svr.q",   "?n3x,?o(b)",	0xf4000002, 0xfc000002, SM|RD_s|RD_C2,			AL	},
+{"svr.q",   "?n3x,A(b)",	0,    (int) M_SVRQ_AB,	INSN_MACRO,			AL	},
+{"mtv",     "t,?d0z",		0x48e00000, 0xffe0ff80, LCD|WR_t|WR_C2,			AL	},
+{"mfv",     "t,?d0z",		0x48600000, 0xffe0ff80, COD|RD_t|WR_CC|RD_C2, 	AL	},
+{"mtvc",    "t,?q",		0x48e00000, 0xffe0ff00, LCD|WR_t|WR_C2,			AL	},
+{"mfvc",    "t,?q",		0x48600000, 0xffe0ff00, COD|RD_t|WR_CC|RD_C2, 	AL	},
+{"vmtvc",   "?q,?s0y",		0xd0510000, 0xffff8000, WR_C2,				AL	},
+{"vmfvc",   "?d0z,?r",		0xd0500000, 0xffff0080, RD_C2,				AL	},
+{"vadd.q",  "?d3d,?s3s,?t3t",	0x60008080, 0xff808080, RD_C2,				AL	},
+{"vsub.q",  "?d3d,?s3s,?t3t",	0x60808080, 0xff808080, RD_C2,				AL	},
+{"vdiv.q",  "?x3z,?s3y,?t3x",	0x63808080, 0xff808080, RD_C2,				AL	},
+{"vmul.q",  "?d3d,?s3s,?t3t",	0x64008080, 0xff808080, RD_C2,				AL	},
+{"vdot.q",  "?d0d,?s3s,?t3t",	0x64808080, 0xff808080, RD_C2,				AL	},
+{"vscl.q",  "?d3d,?s3s,?t0x",	0x65008080, 0xff808080, RD_C2,				AL	},
+{"vhdp.q",  "?d0d,?s3y,?t3t",	0x66008080, 0xff808080, RD_C2,				AL	},
+{"vcmp.q",  "?f2,?s3s,?t3t",	0x6c008080, 0xff8080f0, RD_C2,				AL	},
+{"vcmp.q",  "?f1,?s3s",		0x6c008080, 0xffff80f0, RD_C2,				AL	},
+{"vcmp.q",  "?f0",		0x6c008080, 0xfffffff0, RD_C2,				AL	},
+{"vmin.q",  "?d3d,?s3s,?t3t",	0x6d008080, 0xff808080, RD_C2,				AL	},
+{"vmax.q",  "?d3d,?s3s,?t3t",	0x6d808080, 0xff808080, RD_C2,				AL	},
+{"vsgn.q",  "?d3d,?s3s",	0xd04a8080, 0xffff8080, RD_C2,				AL	},
+{"vcst.q",  "?d3d,?a",		0xd0608080, 0xffe0ff80, RD_C2,				AL	},
+{"vscmp.q", "?d3d,?s3s,?t3t",	0x6e808080, 0xff808080, RD_C2,				AL	},
+{"vsge.q",  "?d3d,?s3s,?t3t",	0x6f008080, 0xff808080, RD_C2,				AL	},
+{"vslt.q",  "?d3d,?s3s,?t3t",	0x6f808080, 0xff808080, RD_C2,				AL	},
+{"vi2uc.q", "?d0m,?s3w",	0xd03c8080, 0xffff8080, RD_C2,				AL	},
+{"vi2c.q",  "?d0m,?s3w",	0xd03d8080, 0xffff8080, RD_C2,				AL	},
+{"vi2us.q", "?d1m,?s3w",	0xd03e8080, 0xffff8080, RD_C2,				AL	},
+{"vi2s.q",  "?d1m,?s3w",	0xd03f8080, 0xffff8080, RD_C2,				AL	},
+{"vmov.q",  "?d3d,?s3s",	0xd0008080, 0xffff8080, RD_C2,				AL	},
+{"vabs.q",  "?d3d,?s3w",	0xd0018080, 0xffff8080, RD_C2,				AL	},
+{"vneg.q",  "?d3d,?s3w",	0xd0028080, 0xffff8080, RD_C2,				AL	},
+{"vidt.q",  "?d3d",		0xd0038080, 0xffffff80, RD_C2,				AL	},
+{"vsat0.q", "?d3z,?s3s",	0xd0048080, 0xffff8080, RD_C2,				AL	},
+{"vsat1.q", "?d3z,?s3s",	0xd0058080, 0xffff8080, RD_C2,				AL	},
+{"vzero.q", "?d3d",		0xd0068080, 0xffffff80, RD_C2,		AL	},
+{"vone.q",  "?d3d",		0xd0078080, 0xffffff80, RD_C2,				AL	},
+{"vrcp.q",  "?x3z,?s3y",	0xd0108080, 0xffff8080, RD_C2,				AL	},
+{"vrsq.q",  "?x3z,?s3y",	0xd0118080, 0xffff8080, RD_C2,				AL	},
+{"vsin.q",  "?x3z,?s3y",	0xd0128080, 0xffff8080, RD_C2,				AL	},
+{"vcos.q",  "?x3z,?s3y",	0xd0138080, 0xffff8080, RD_C2,				AL	},
+{"vexp2.q", "?x3z,?s3y",	0xd0148080, 0xffff8080, RD_C2,				AL	},
+{"vlog2.q", "?x3z,?s3y",	0xd0158080, 0xffff8080, RD_C2,		AL	},
+{"vsqrt.q", "?x3z,?s3y",	0xd0168080, 0xffff8080, RD_C2,				AL	},
+{"vasin.q", "?x3z,?s3y",	0xd0178080, 0xffff8080, RD_C2,				AL	},
+{"vnrcp.q", "?x3z,?s3y",	0xd0188080, 0xffff8080, RD_C2,				AL	},
+{"vnsin.q", "?x3z,?s3y",	0xd01a8080, 0xffff8080, RD_C2,				AL	},
+{"vrexp2.q", "?x3z,?s3y",	0xd01c8080, 0xffff8080, RD_C2,				AL	},
+{"vrndi.q", "?d3z",		0xd0218080, 0xffffff80, RD_C2,				AL	},
+{"vrndf1.q", "?d3z",		0xd0228080, 0xffffff80, RD_C2,				AL	},
+{"vrndf2.q", "?d3z",		0xd0238080, 0xffffff80, RD_C2,				AL	},
+{"vf2h.q",  "?d1m,?s3s",	0xd0328080, 0xffff8080, RD_C2,				AL	},
+{"vsrt1.q", "?d3d,?s3s",	0xd0408080, 0xffff8080, RD_C2,				AL	},
+{"vsrt2.q", "?d3d,?s3s",	0xd0418080, 0xffff8080, RD_C2,				AL	},
+{"vsrt3.q", "?d3d,?s3s",	0xd0488080, 0xffff8080, RD_C2,				AL	},
+{"vsrt4.q", "?d3d,?s3s",	0xd0498080, 0xffff8080, RD_C2,				AL	},
+{"vbfy1.q", "?d3d,?s3s",	0xd0428080, 0xffff8080, RD_C2,				AL	},
+{"vbfy2.q", "?d3d,?s3s",	0xd0438080, 0xffff8080, RD_C2,				AL	},
+{"vocp.q",  "?d3d,?s3y",	0xd0448080, 0xffff8080, RD_C2,				AL	},
+{"vfad.q",  "?d0d,?s3s",	0xd0468080, 0xffff8080, RD_C2,				AL	},
+{"vavg.q",  "?d0d,?s3s",	0xd0478080, 0xffff8080, RD_C2,				AL	},
+{"vf2in.q", "?d3m,?s3s,?b",	0xd2008080, 0xffe08080, RD_C2,				AL	},
+{"vf2iz.q", "?d3m,?s3s,?b",	0xd2208080, 0xffe08080, RD_C2,				AL	},
+{"vf2iu.q", "?d3m,?s3s,?b",	0xd2408080, 0xffe08080, RD_C2,				AL	},
+{"vf2id.q", "?d3m,?s3s,?b",	0xd2608080, 0xffe08080, RD_C2,				AL	},
+{"vi2f.q",  "?d3d,?s3w,?b",	0xd2808080, 0xffe08080, RD_C2,				AL	},
+{"vcmov.q", "?d3d,?s3s,?e",	0,    (int) M_VCMOVQ,	INSN_MACRO,			AL	},
+{"vcmovt.q", "?d3d,?s3s,?e",	0xd2a08080, 0xfff88080, RD_C2,				AL	},
+{"vcmovf.q", "?d3d,?s3s,?e",	0xd2a88080, 0xfff88080, RD_C2,				AL	},
+{"vmmul.q", "?v7z,?s7y,?t7x",	0xf0008080, 0xff808080, RD_C2,				AL	},
+{"vtfm4.q", "?v3z,?s7y,?t3x",	0xf1808080, 0xff808080, RD_C2,				AL	},
+{"vhtfm4.q", "?v3z,?s7y,?t3x",	0xf1808000, 0xff808080, RD_C2,				AL	},
+{"vmscl.q", "?x7z,?s7y,?t0x",	0xf2008080, 0xff808080, RD_C2,				AL	},
+{"vqmul.q", "?v3z,?s3y,?t3x",	0xf2808080, 0xff808080, RD_C2,				AL	},
+{"vmmov.q", "?x7z,?s7y",	0xf3808080, 0xffff8080, RD_C2,				AL	},
+{"vmidt.q", "?d7z",		0xf3838080, 0xffffff80, RD_C2,				AL	},
+{"vmzero.q", "?d7z",		0xf3868080, 0xffffff80, RD_C2,				AL	},
+{"vmone.q", "?d7z",		0xf3878080, 0xffffff80, RD_C2,				AL	},
+{"vrot.q",  "?x3z,?s0y,?w",	0xf3a08080, 0xffe08080, RD_C2,				AL	},
+{"vt4444.q", "?d1z,?s3w",	0xd0598080, 0xffff8080, RD_C2,				AL	},
+{"vt5551.q", "?d1z,?s3w",	0xd05a8080, 0xffff8080, RD_C2,				AL	},
+{"vt5650.q", "?d1z,?s3w",	0xd05b8080, 0xffff8080, RD_C2,				AL	},
+{"vadd.t",  "?d2d,?s2s,?t2t",	0x60008000, 0xff808080, RD_C2,				AL	},
+{"vsub.t",  "?d2d,?s2s,?t2t",	0x60808000, 0xff808080, RD_C2,				AL	},
+{"vdiv.t",  "?x2z,?s2y,?t2x",	0x63808000, 0xff808080, RD_C2,				AL	},
+{"vmul.t",  "?d2d,?s2s,?t2t",	0x64008000, 0xff808080, RD_C2,				AL	},
+{"vdot.t",  "?d0d,?s2s,?t2t",	0x64808000, 0xff808080, RD_C2,				AL	},
+{"vscl.t",  "?d2d,?s2s,?t0x",	0x65008000, 0xff808080, RD_C2,				AL	},
+{"vhdp.t",  "?d0d,?s2y,?t2t",	0x66008000, 0xff808080, RD_C2,				AL	},
+{"vcrs.t",  "?d2d,?s2y,?t2x",	0x66808000, 0xff808080, RD_C2,				AL	},
+{"vcmp.t",  "?f2,?s2s,?t2t",	0x6c008000, 0xff8080f0, RD_C2,				AL	},
+{"vcmp.t",  "?f1,?s2s",		0x6c008000, 0xffff80f0, RD_C2,				AL	},
+{"vcmp.t",  "?f0",		0x6c008000, 0xfffffff0, RD_C2,				AL	},
+{"vmin.t",  "?d2d,?s2s,?t2t",	0x6d008000, 0xff808080, RD_C2,				AL	},
+{"vmax.t",  "?d2d,?s2s,?t2t",	0x6d808000, 0xff808080, RD_C2,				AL	},
+{"vsgn.t",  "?d2d,?s2s",	0xd04a8000, 0xffff8080, RD_C2,				AL	},
+{"vcst.t",  "?d2d,?a",		0xd0608000, 0xffe0ff80, RD_C2,				AL	},
+{"vscmp.t", "?d2d,?s2s,?t2t",	0x6e808000, 0xff808080, RD_C2,				AL	},
+{"vsge.t",  "?d2d,?s2s,?t2t",	0x6f008000, 0xff808080, RD_C2,				AL	},
+{"vslt.t",  "?d2d,?s2s,?t2t",	0x6f808000, 0xff808080, RD_C2,				AL	},
+{"vmov.t",  "?d2d,?s2s",	0xd0008000, 0xffff8080, RD_C2,				AL	},
+{"vabs.t",  "?d2d,?s2w",	0xd0018000, 0xffff8080, RD_C2,				AL	},
+{"vneg.t",  "?d2d,?s2w",	0xd0028000, 0xffff8080, RD_C2,				AL	},
+{"vsat0.t", "?d2z,?s2s",	0xd0048000, 0xffff8080, RD_C2,				AL	},
+{"vsat1.t", "?d2z,?s2s",	0xd0058000, 0xffff8080, RD_C2,				AL	},
+{"vzero.t", "?d2d",		0xd0068000, 0xffffff80, RD_C2,				AL	},
+{"vone.t",  "?d2d",		0xd0078000, 0xffffff80, RD_C2,				AL	},
+{"vrcp.t",  "?x2z,?s2y",	0xd0108000, 0xffff8080, RD_C2,				AL	},
+{"vrsq.t",  "?x2z,?s2y",	0xd0118000, 0xffff8080, RD_C2,				AL	},
+{"vsin.t",  "?x2z,?s2y",	0xd0128000, 0xffff8080, RD_C2,				AL	},
+{"vcos.t",  "?x2z,?s2y",	0xd0138000, 0xffff8080, RD_C2,				AL	},
+{"vexp2.t", "?x2z,?s2y",	0xd0148000, 0xffff8080, RD_C2,				AL	},
+{"vlog2.t", "?x2z,?s2y",	0xd0158000, 0xffff8080, RD_C2,				AL	},
+{"vsqrt.t", "?x2z,?s2y",	0xd0168000, 0xffff8080, RD_C2,				AL	},
+{"vasin.t", "?x2z,?s2y",	0xd0178000, 0xffff8080, RD_C2,				AL	},
+{"vnrcp.t", "?x2z,?s2y",	0xd0188000, 0xffff8080, RD_C2,				AL	},
+{"vnsin.t", "?x2z,?s2y",	0xd01a8000, 0xffff8080, RD_C2,				AL	},
+{"vrexp2.t", "?x2z,?s2y",	0xd01c8000, 0xffff8080, RD_C2,				AL	},
+{"vrndi.t", "?d2z",		0xd0218000, 0xffffff80, RD_C2,				AL	},
+{"vrndf1.t", "?d2z",		0xd0228000, 0xffffff80, RD_C2,				AL	},
+{"vrndf2.t", "?d2z",		0xd0238000, 0xffffff80, RD_C2,				AL	},
+{"vocp.t",  "?d2d,?s2y",	0xd0448000, 0xffff8080, RD_C2,				AL	},
+{"vfad.t",  "?d0d,?s2s",	0xd0468000, 0xffff8080, RD_C2,				AL	},
+{"vavg.t",  "?d0d,?s2s",	0xd0478000, 0xffff8080, RD_C2,				AL	},
+{"vf2in.t", "?d2m,?s2s,?b",	0xd2008000, 0xffe08080, RD_C2,				AL	},
+{"vf2iz.t", "?d2m,?s2s,?b",	0xd2208000, 0xffe08080, RD_C2,				AL	},
+{"vf2iu.t", "?d2m,?s2s,?b",	0xd2408000, 0xffe08080, RD_C2,				AL	},
+{"vf2id.t", "?d2m,?s2s,?b",	0xd2608000, 0xffe08080, RD_C2,				AL	},
+{"vi2f.t",  "?d2d,?s2w,?b",	0xd2808000, 0xffe08080, RD_C2,				AL	},
+{"vcmov.t", "?d2d,?s2s,?e",	0,    (int) M_VCMOVT,	INSN_MACRO,			AL	},
+{"vcmovt.t", "?d2d,?s2s,?e",	0xd2a08000, 0xfff88080, RD_C2,				AL	},
+{"vcmovf.t", "?d2d,?s2s,?e",	0xd2a88000, 0xfff88080, RD_C2,				AL	},
+{"vmmul.t", "?v6z,?s6y,?t6x",	0xf0008000, 0xff808080, RD_C2,				AL	},
+{"vtfm3.t", "?v2z,?s6y,?t2x",	0xf1008000, 0xff808080, RD_C2,				AL	},
+{"vhtfm3.t", "?v2z,?s6y,?t2x",	0xf1000080, 0xff808080, RD_C2,				AL	},
+{"vmscl.t", "?x6z,?s6y,?t0x",	0xf2008000, 0xff808080, RD_C2,				AL	},
+{"vmmov.t", "?x6z,?s6y",	0xf3808000, 0xffff8080, RD_C2,				AL	},
+{"vmidt.t", "?d6z",		0xf3838000, 0xffffff80, RD_C2,				AL	},
+{"vmzero.t", "?d6z",		0xf3868000, 0xffffff80, RD_C2,				AL	},
+{"vmone.t", "?d6z",		0xf3878000, 0xffffff80, RD_C2,				AL	},
+{"vrot.t",  "?x2z,?s0y,?w",	0xf3a08000, 0xffe08080, RD_C2,				AL	},
+{"vcrsp.t", "?d2z,?s2y,?t2x",	0xf2808000, 0xff808080, RD_C2,				AL	},
+{"vadd.p",  "?d1d,?s1s,?t1t",	0x60000080, 0xff808080, RD_C2,				AL	},
+{"vsub.p",  "?d1d,?s1s,?t1t",	0x60800080, 0xff808080, RD_C2,				AL	},
+{"vdiv.p",  "?x1z,?s1y,?t1x",	0x63800080, 0xff808080, RD_C2,				AL	},
+{"vmul.p",  "?d1d,?s1s,?t1t",	0x64000080, 0xff808080, RD_C2,				AL	},
+{"vdot.p",  "?d0d,?s1s,?t1t",	0x64800080, 0xff808080, RD_C2,				AL	},
+{"vscl.p",  "?d1d,?s1s,?t0x",	0x65000080, 0xff808080, RD_C2,				AL	},
+{"vhdp.p",  "?d0d,?s1y,?t1t",	0x66000080, 0xff808080, RD_C2,				AL	},
+{"vdet.p",  "?d0d,?s1s,?t1x",	0x67000080, 0xff808080, RD_C2,				AL	},
+{"vcmp.p",  "?f2,?s1s,?t1t",	0x6c000080, 0xff8080f0, RD_C2,				AL	},
+{"vcmp.p",  "?f1,?s1s",		0x6c000080, 0xffff80f0, RD_C2,				AL	},
+{"vcmp.p",  "?f0",		0x6c000080, 0xfffffff0, RD_C2,				AL	},
+{"vmin.p",  "?d1d,?s1s,?t1t",	0x6d000080, 0xff808080, RD_C2,				AL	},
+{"vmax.p",  "?d1d,?s1s,?t1t",	0x6d800080, 0xff808080, RD_C2,				AL	},
+{"vsgn.p",  "?d1d,?s1s",	0xd04a0080, 0xffff8080, RD_C2,				AL	},
+{"vcst.p",  "?d1d,?a",		0xd0600080, 0xffe0ff80, RD_C2,				AL	},
+{"vscmp.p", "?d1d,?s1s,?t1t",	0x6e800080, 0xff808080, RD_C2,				AL	},
+{"vsge.p",  "?d1d,?s1s,?t1t",	0x6f000080, 0xff808080, RD_C2,				AL	},
+{"vslt.p",  "?d1d,?s1s,?t1t",	0x6f800080, 0xff808080, RD_C2,				AL	},
+{"vus2i.p", "?d3m,?s1y",	0xd03a0080, 0xffff8080, RD_C2,				AL	},
+{"vs2i.p",  "?d3m,?s1y",	0xd03b0080, 0xffff8080, RD_C2,				AL	},
+{"vi2us.p", "?d0m,?s1w",	0xd03e0080, 0xffff8080, RD_C2,				AL	},
+{"vi2s.p",  "?d0m,?s1w",	0xd03f0080, 0xffff8080, RD_C2,				AL	},
+{"vmov.p",  "?d1d,?s1s",	0xd0000080, 0xffff8080, RD_C2,				AL	},
+{"vabs.p",  "?d1d,?s1w",	0xd0010080, 0xffff8080, RD_C2,				AL	},
+{"vneg.p",  "?d1d,?s1w",	0xd0020080, 0xffff8080, RD_C2,				AL	},
+{"vidt.p",  "?d1d",		0xd0030080, 0xffffff80, RD_C2,				AL	},
+{"vsat0.p", "?d1z,?s1s",	0xd0040080, 0xffff8080, RD_C2,				AL	},
+{"vsat1.p", "?d1z,?s1s",	0xd0050080, 0xffff8080, RD_C2,				AL	},
+{"vzero.p", "?d1d",		0xd0060080, 0xffffff80, RD_C2,				AL	},
+{"vone.p",  "?d1d",		0xd0070080, 0xffffff80, RD_C2,				AL	},
+{"vrcp.p",  "?x1z,?s1y",	0xd0100080, 0xffff8080, RD_C2,				AL	},
+{"vrsq.p",  "?x1z,?s1y",	0xd0110080, 0xffff8080, RD_C2,				AL	},
+{"vsin.p",  "?x1z,?s1y",	0xd0120080, 0xffff8080, RD_C2,				AL	},
+{"vcos.p",  "?x1z,?s1y",	0xd0130080, 0xffff8080, RD_C2,				AL	},
+{"vexp2.p", "?x1z,?s1y",	0xd0140080, 0xffff8080, RD_C2,				AL	},
+{"vlog2.p", "?x1z,?s1y",	0xd0150080, 0xffff8080, RD_C2,				AL	},
+{"vsqrt.p", "?x1z,?s1y",	0xd0160080, 0xffff8080, RD_C2,				AL	},
+{"vasin.p", "?x1z,?s1y",	0xd0170080, 0xffff8080, RD_C2,				AL	},
+{"vnrcp.p", "?x1z,?s1y",	0xd0180080, 0xffff8080, RD_C2,				AL	},
+{"vnsin.p", "?x1z,?s1y",	0xd01a0080, 0xffff8080, RD_C2,				AL	},
+{"vrexp2.p", "?x1z,?s1y",	0xd01c0080, 0xffff8080, RD_C2,				AL	},
+{"vrndi.p", "?d1z",		0xd0210080, 0xffffff80, RD_C2,				AL	},
+{"vrndf1.p", "?d1z",		0xd0220080, 0xffffff80, RD_C2,				AL	},
+{"vrndf2.p", "?d1z",		0xd0230080, 0xffffff80, RD_C2,				AL	},
+{"vf2h.p",  "?d0m,?s1s",	0xd0320080, 0xffff8080, RD_C2,				AL	},
+{"vh2f.p",  "?d3d,?s1y",	0xd0330080, 0xffff8080, RD_C2,				AL	},
+{"vbfy1.p", "?d1d,?s1s",	0xd0420080, 0xffff8080, RD_C2,				AL	},
+{"vocp.p",  "?d1d,?s1y",	0xd0440080, 0xffff8080, RD_C2,				AL	},
+{"vsocp.p", "?d3z,?s1y",	0xd0450080, 0xffff8080, RD_C2,				AL	},
+{"vfad.p",  "?d0d,?s1s",	0xd0460080, 0xffff8080, RD_C2,				AL	},
+{"vavg.p",  "?d0d,?s1s",	0xd0470080, 0xffff8080, RD_C2,				AL	},
+{"vf2in.p", "?d1m,?s1s,?b",	0xd2000080, 0xffe08080, RD_C2,				AL	},
+{"vf2iz.p", "?d1m,?s1s,?b",	0xd2200080, 0xffe08080, RD_C2,				AL	},
+{"vf2iu.p", "?d1m,?s1s,?b",	0xd2400080, 0xffe08080, RD_C2,				AL	},
+{"vf2id.p", "?d1m,?s1s,?b",	0xd2600080, 0xffe08080, RD_C2,				AL	},
+{"vi2f.p",  "?d1d,?s1w,?b",	0xd2800080, 0xffe08080, RD_C2,				AL	},
+{"vcmov.p", "?d1d,?s1s,?e",	0,    (int) M_VCMOVP,	INSN_MACRO,			AL	},
+{"vcmovt.p", "?d1d,?s1s,?e",	0xd2a00080, 0xfff88080, RD_C2,				AL	},
+{"vcmovf.p", "?d1d,?s1s,?e",	0xd2a80080, 0xfff88080, RD_C2,				AL	},
+{"vmmul.p", "?v5z,?s5y,?t5x",	0xf0000080, 0xff808080, RD_C2,				AL	},
+{"vtfm2.p", "?v1z,?s5y,?t1x",	0xf0800080, 0xff808080, RD_C2,				AL	},
+{"vhtfm2.p", "?v1z,?s5y,?t1x",	0xf0800000, 0xff808080, RD_C2,				AL	},
+{"vmscl.p", "?x5z,?s5y,?t0x",	0xf2000080, 0xff808080, RD_C2,				AL	},
+{"vmmov.p", "?x5z,?s5y",	0xf3800080, 0xffff8080, RD_C2,				AL	},
+{"vmidt.p", "?d5z",		0xf3830080, 0xffffff80, RD_C2,				AL	},
+{"vmzero.p", "?d5z",		0xf3860080, 0xffffff80, RD_C2,				AL	},
+{"vmone.p", "?d5z",		0xf3870080, 0xffffff80, RD_C2,				AL	},
+{"vrot.p",  "?x1z,?s0y,?w",	0xf3a00080, 0xffe08080, RD_C2,				AL	},
+{"vadd.s",  "?d0d,?s0s,?t0t",	0x60000000, 0xff808080, RD_C2,				AL	},
+{"vsub.s",  "?d0d,?s0s,?t0t",	0x60800000, 0xff808080, RD_C2,				AL	},
+{"vdiv.s",  "?x0d,?s0s,?t0t",	0x63800000, 0xff808080, RD_C2,				AL	},
+{"vmul.s",  "?d0d,?s0s,?t0t",	0x64000000, 0xff808080, RD_C2,				AL	},
+{"vcmp.s",  "?f2,?s0s,?t0t",	0x6c000000, 0xff8080f0, RD_C2,				AL	},
+{"vcmp.s",  "?f1,?s0s",		0x6c000000, 0xffff80f0, RD_C2,				AL	},
+{"vcmp.s",  "?f0",		0x6c000000, 0xfffffff0, RD_C2,				AL	},
+{"vmin.s",  "?d0d,?s0s,?t0t",	0x6d000000, 0xff808080, RD_C2,				AL	},
+{"vmax.s",  "?d0d,?s0s,?t0t",	0x6d800000, 0xff808080, RD_C2,				AL	},
+{"vsgn.s",  "?d0d,?s0s",	0xd04a0000, 0xffff8080, RD_C2,				AL	},
+{"vcst.s",  "?d0d,?a",		0xd0600000, 0xffe0ff80, RD_C2,				AL	},
+{"vscmp.s", "?d0d,?s0s,?t0t",	0x6e800000, 0xff808080, RD_C2,				AL	},
+{"vsge.s",  "?d0d,?s0s,?t0t",	0x6f000000, 0xff808080, RD_C2,				AL	},
+{"vslt.s",  "?d0d,?s0s,?t0t",	0x6f800000, 0xff808080, RD_C2,				AL	},
+{"vus2i.s", "?d1m,?s0y",	0xd03a0000, 0xffff8080, RD_C2,				AL	},
+{"vs2i.s",  "?d1m,?s0y",	0xd03b0000, 0xffff8080, RD_C2,				AL	},
+{"vmov.s",  "?d0d,?s0s",	0xd0000000, 0xffff8080, RD_C2,				AL	},
+{"vabs.s",  "?d0d,?s0w",	0xd0010000, 0xffff8080, RD_C2,				AL	},
+{"vneg.s",  "?d0d,?s0w",	0xd0020000, 0xffff8080, RD_C2,				AL	},
+{"vsat0.s", "?d0z,?s0s",	0xd0040000, 0xffff8080, RD_C2,				AL	},
+{"vsat1.s", "?d0z,?s0s",	0xd0050000, 0xffff8080, RD_C2,				AL	},
+{"vzero.s", "?d0d",		0xd0060000, 0xffffff80, RD_C2,				AL	},
+{"vone.s",  "?d0d",		0xd0070000, 0xffffff80, RD_C2,				AL	},
+{"vrcp.s",  "?x0d,?s0s",	0xd0100000, 0xffff8080, RD_C2,				AL	},
+{"vrsq.s",  "?x0d,?s0s",	0xd0110000, 0xffff8080, RD_C2,				AL	},
+{"vsin.s",  "?x0d,?s0s",	0xd0120000, 0xffff8080, RD_C2,				AL	},
+{"vcos.s",  "?x0d,?s0s",	0xd0130000, 0xffff8080, RD_C2,				AL	},
+{"vexp2.s", "?x0d,?s0s",	0xd0140000, 0xffff8080, RD_C2,				AL	},
+{"vlog2.s", "?x0d,?s0s",	0xd0150000, 0xffff8080, RD_C2,				AL	},
+{"vsqrt.s", "?x0d,?s0s",	0xd0160000, 0xffff8080, RD_C2,				AL	},
+{"vasin.s", "?x0d,?s0s",	0xd0170000, 0xffff8080, RD_C2,				AL	},
+{"vnrcp.s", "?x0d,?s0y",	0xd0180000, 0xffff8080, RD_C2,				AL	},
+{"vnsin.s", "?x0d,?s0y",	0xd01a0000, 0xffff8080, RD_C2,				AL	},
+{"vrexp2.s", "?x0d,?s0y",	0xd01c0000, 0xffff8080, RD_C2,				AL	},
+{"vrnds.s", "?s0y",		0xd0200000, 0xffff80ff, RD_C2,				AL	},
+{"vrndi.s", "?d0d",		0xd0210000, 0xffffff80, RD_C2,				AL	},
+{"vrndf1.s", "?d0d",		0xd0220000, 0xffffff80, RD_C2,				AL	},
+{"vrndf2.s", "?d0d",		0xd0230000, 0xffffff80, RD_C2,				AL	},
+{"vh2f.s",  "?d1d,?s0y",	0xd0330000, 0xffff8080, RD_C2,				AL	},
+{"vsbz.s",  "?d0d,?s0s",	0xd0360000, 0xffff8080, RD_C2,				AL	},
+{"vsbn.s",  "?d0d,?s0s,?t0t",	0x61000000, 0xff808080, RD_C2,				AL	},
+{"vlgb.s",  "?d0d,?s0s",	0xd0370000, 0xffff8080, RD_C2,				AL	},
+{"vocp.s",  "?d0d,?s0y",	0xd0440000, 0xffff8080, RD_C2,				AL	},
+{"vsocp.s", "?d1z,?s0y",	0xd0450000, 0xffff8080, RD_C2,				AL	},
+{"vf2in.s", "?d0m,?s0s,?b",	0xd2000000, 0xffe08080, RD_C2,				AL	},
+{"vf2iz.s", "?d0m,?s0s,?b",	0xd2200000, 0xffe08080, RD_C2,				AL	},
+{"vf2iu.s", "?d0m,?s0s,?b",	0xd2400000, 0xffe08080, RD_C2,				AL	},
+{"vf2id.s", "?d0m,?s0s,?b",	0xd2600000, 0xffe08080, RD_C2,				AL	},
+{"vi2f.s",  "?d0d,?s0w,?b",	0xd2800000, 0xffe08080, RD_C2,				AL	},
+{"vcmov.s", "?d0d,?s0s,?e",	0,    (int) M_VCMOVS,	INSN_MACRO,			AL	},
+{"vcmovt.s", "?d0d,?s0s,?e",	0xd2a00000, 0xfff88080, RD_C2,				AL	},
+{"vcmovf.s", "?d0d,?s0s,?e",	0xd2a80000, 0xfff88080, RD_C2,				AL	},
+{"vwbn.s",  "?d0d,?s0s,?i",	0xd3000000, 0xff008080, RD_C2,				AL	},
+{"vpfxs",   "?0,?1,?2,?3",	0xdc000000, 0xff000000, RD_C2,				AL	},
+{"vpfxt",   "?0,?1,?2,?3",	0xdd000000, 0xff000000, RD_C2,				AL	},
+{"vpfxd",   "?4,?5,?6,?7",	0xde000000, 0xff000000, RD_C2,				AL	},
+{"viim.s",  "?t0d,j",		0xdf000000, 0xff800000, RD_C2,				AL	},
+{"vfim.s",  "?t0d,?u",		0xdf800000, 0xff800000, RD_C2,				AL	},
+{"vnop",    "",			0xffff0000, 0xffffffff, RD_C2,				AL	},
+{"vflush",  "",			0xffff040d, 0xffffffff, RD_C2,				AL	},
+{"vsync",   "",			0xffff0320, 0xffffffff, RD_C2,				AL	},
+{"vsync",   "i",		0xffff0000, 0xffff0000, RD_C2,				AL	},
+
+/* Coprocessor 2 load/store operations overlap with the Allegrex VFPU
+   instructions so they are here for the latters to take precedence.  */
+/* COP1 ldc1 and sdc1 and COP3 ldc3 and sdc3 also overlap with the VFPU.  */
+{"ldc1",    "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,			I2	},
+{"ldc1",    "E,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,			I2	},
+{"ldc1",    "T,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,				I2	},
+{"ldc1",    "E,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,				I2	},
+{"l.d",     "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,			I2	}, /* ldc1 */
+{"l.d",     "T,o(b)",	0,    (int) M_L_DOB,	INSN_MACRO,				I1	},
+{"l.d",     "T,A(b)",	0,    (int) M_L_DAB,	INSN_MACRO,				I1	},
+{"ldc2",    "E,o(b)",	0xd8000000, 0xfc000000, CLD|RD_b|WR_CC,				I2	},
+{"ldc2",    "E,A(b)",	0,    (int) M_LDC2_AB,	INSN_MACRO,				I2	},
+{"ldc3",    "E,o(b)",	0xdc000000, 0xfc000000, CLD|RD_b|WR_CC,				I2	},
+{"ldc3",    "E,A(b)",	0,    (int) M_LDC3_AB,	INSN_MACRO,				I2	},
+{"lwc2",    "E,o(b)",	0xc8000000, 0xfc000000,	CLD|RD_b|WR_CC,				I1	},
+{"lwc2",    "E,A(b)",	0,    (int) M_LWC2_AB,	INSN_MACRO,				I1	},
+{"sdc1",    "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,			I2	},
+{"sdc1",    "E,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,			I2	},
+{"sdc1",    "T,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,				I2	},
+{"sdc1",    "E,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,				I2	},
+{"s.d",     "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,			I2	},
+{"s.d",     "T,o(b)",	0,    (int) M_S_DOB,	INSN_MACRO,				I1	},
+{"s.d",     "T,A(b)",	0,    (int) M_S_DAB,	INSN_MACRO,				I1	},
+{"sdc2",    "E,o(b)",	0xf8000000, 0xfc000000, SM|RD_C2|RD_b,				I2	},
+{"sdc2",    "E,A(b)",	0,    (int) M_SDC2_AB,	INSN_MACRO,				I2	},
+{"sdc3",    "E,o(b)",	0xfc000000, 0xfc000000, SM|RD_C3|RD_b,				I2	},
+{"sdc3",    "E,A(b)",	0,    (int) M_SDC3_AB,	INSN_MACRO,				I2	},
+{"swc2",    "E,o(b)",	0xe8000000, 0xfc000000,	SM|RD_C2|RD_b,				I1	},
+{"swc2",    "E,A(b)",	0,    (int) M_SWC2_AB,	INSN_MACRO,				I1	},
+
 /* No hazard protection on coprocessor instructions--they shouldn't
    change the state of the processor and if they do it's up to the
    user to put in nops as necessary.  These are at the end so that the
